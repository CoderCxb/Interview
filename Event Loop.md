### 1. 线程和进程

- 进程：系统分配的独立资源，是 CPU 资源分配的基本单位，进程是由一个或者多个线程组成的。
- 线程:   进程的执行流，是CPU调度和分派的基本单位，同个进程之中的多个线程之间是共享该进程的资源的。

### 2. 浏览器内核

- 浏览器是多进程的，每个Tab都代表一个独立进程，浏览器内核属于多进程的一种。

- 浏览器内核有多个线程

  - GUI渲染线程：
    - 负责渲染页面，解析 HTML，CSS 构成 DOM 树等。
    - 和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。
  - JS 引擎线程:
    - 单线程工作，负责解析运行 JavaScript 脚本。
    - JS有时需要对DOM进行操作，因此需要在DOM渲染完毕后调用，因此和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。
  - 事件触发线程:
    - 当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。
  - 定时器触发线程:
    - 浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。
    - 开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。
  - http 请求线程:
    - http 请求的时候会开启一条请求线程。
    - 请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。

  

### 3. JavaScript引擎

- Javascript 是单线程，JS的主要用途是和用户交互以及操作DOM，如果JS拥有多个线程同时操作，那么就会有复杂的同步问题(以谁为准)。
- HTML5 提出了Web Worker API，主要是为了解决页面阻塞的问题，创建工作线程执行任务，本质上还是单线程的。



### 4. 事件循环

![img](image/9.png)

- 微任务(Microtask): script标签、setTimeout、setInterval、I/O、UI  Rendering。
- 宏任务(Macrotask): Promise、MutationObserver、process.nextTick(Node)。
- 执行栈(Call Stack):  当任务执行完毕时，就会将其移除。

注意：setTimeout和setInterval并不是定时之后马上执行，它们的含义是定时之后，将回调加入到宏任务队列。



![](images\10.png)

流程文字版: 

- 程序执行，碰到script标签为宏任务，将其添加到 Task Queque(宏任务队列), 此时没有同步代码并且微任务为空，将script推入Call Stack(执行栈)。
- 执行script标签中的代码，同步代码直接进入主线程执行，而微任务和宏任务则等待异步的结果，待获取到异步结果后将**回调**加入各自的任务队列。
- 主线程同步代码执行完毕，首先检查微任务队列，若微任务队列中有任务，则依次推入执行栈。（同步代码直接执行，异步代码同上，执行完就出栈）
- 待微任务队列为空时，开始将宏任务推入执行栈。（每次执行宏任务前，都会先检查微任务队列，只有微任务队列为空才会执行宏任务）

微任务中可以包含宏任务，宏任务也可以包含微任务，因此不断的循环检查，即事件循环。

为什么要有事件循环？

- js是单线程的，为了防止I/O等异步的操作阻塞主线程，提出了一套事件循环机制，通过将异步的操作挂起，继续执行后续代码，等到异步结果出来，在执行其回调函数，从而保证主线程的通畅。

