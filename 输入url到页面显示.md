### 1. **输入url到页面加载都发生了什么事情？**

###### 1.1 输入URL并解析

a)输入URL后,浏览器会对URL进行解析,获取URL中包含的协议、主机、端口、路径、参数等.

b)在浏览器发送HTTP请求前,首先根据请求头中的`expires`和`cache-control`判断是否命中强缓存(命中则看强缓存是否过期),如果命中,则直接从缓存中获取资源,不会往服务器发送请求。

c)没有命中强缓存时,浏览器会发送请求，根据请求头的`Last-Modified 和 If-Modified-Since`或 `etag 和 If-None-Match`判断是否命中协商缓存(推荐etag)，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。

d)都没有命中时，则直接从服务器获取资源。

###### 1.2 DNS域名解析

a) 首先查看本机的hosts文件

b) 本地DNS的缓存(访问过会有缓存)

c) DNS服务器缓存(前两个都没有时，向DNS服务器查询,DNS服务器也是优先查找自己本地缓存)

d) DNS服务器查找(DNS没有缓存时,递归查找) ,如 www.baidu.com. 这个域名,默认情况下末尾的.会被省略(等价于.root)。首先查询根域名.root, 获取顶级域名 .com的NS(Name Server - 名称) 和 A(Address - ip地址), 然后再查询顶级域名获取二级域名 .baidu.com的NS和A,再查询二级域名获取 www.baidu.com的NS和A.

e) 这时浏览器就获取到了这个域名对应的ip地址,并会对其进行缓存,不同的浏览器的缓存时间也不同。

f) DNS还有负载均衡的功能,当一个网站对应多个服务器的时候,在相应DNS查询的时候，对不同的查询返回不同的解析结果(ip地址)，这样访问就会被分散开,达到负载均衡的效果。

###### 1.3 TCP/IP连接

三次握手:  

​	i) 第一次: 浏览器向服务器发送一个连接请求报文(确保浏览器的发送能力)

​	ii) 第二次: 服务器接收到请求报文后 向浏览器发送确认报文  (确保服务器的发送能力)

​	iii) 第三次: 浏览器接收到确认后，向服务器发送确认报文 (确保浏览器的接收能力)



###### 1.4  HTTP 请求

![img](C:\Users\bnqkl\Desktop\Interview\images\4.jpg)

**HTTPS**

在HTTP的基础上加上一层TLS(传输层安全性协议)或 SSL(安全套接层),就构成了HTTPS.

###### 1.5 服务器处理请求并返回HTTP报文

服务器上会安装Web Server，如apche、nginx、IIS等。

HTTP请求一般可分为2类:静态资源和动态资源，静态资源直接根据url地址去服务器中找，动态资源则需要根据相应的程序处理，比如 node写的api接口，然后将程序处理的结果返回给浏览器。

###### 1.6 浏览器渲染页面

![img](C:\Users\bnqkl\Desktop\Interview\images\5.jpg)

a) 将HTML解析成DOM Tree

b) 将CSS解析成CSSOM Tree 

c) 将DOM Tree和 CSSOM Tree构建成渲染树

![img](C:\Users\bnqkl\Desktop\Interview\images\7.png)

d) 进行重绘和回流

​	i)  重绘: 当页面中元素样式发生改变但是不影响它在文档流中的位置时(color,background-color)，浏览器会将新的样式赋予元素并重新绘制。

​	ii) 回流: 当Render Tree中部分或全部元素的尺寸、结构或者某些属性发生改变时，浏览器重新渲染部分或全部文档的过程。

e) 渲染过程中遇到<script>就会停止渲染,执行JS代码。 因为浏览器的GUI线程和JS引擎线程是互斥的,JS的加载、解析和渲染都会阻塞DOM的构建。一般将DOM放在底部或者给<script>加上defer和async属性。 由于JS可以改变css样式,如果JS想访问css并改变它，则在执行JS前就得拿到完成的CSSOM，因此这种情况下,浏览器会先下载和构建CSSOM，然后再执行JS，最后再构建DOM。

补充: 

1. async和defer的区别:  

![async和defer](C:\Users\bnqkl\Desktop\Interview\images\8.png)

​	a）默认情况下,浏览器会直接加载并执行脚本,不会等DOM加载完毕。

​	b) defer: 加载JS的阶段不会阻塞HTML解析,等到HTML解析完毕后执行JS代码。

​	c) async: 加载JS的截断不会阻塞HTML解析,JS加载完毕立即执行,执行时会阻塞HTML解析。

​	总结：执行时机不同, 并且加载多个JS脚本时,async是无序加载,defer是有序的。




###### 1.7 关闭连接

四次挥手:

​	i) 第一次: 浏览器向服务器发送释放连接报文。

​	ii) 第二次: 服务器接收到后 向浏览器发送确认报文,浏览器接收到后就进入等待终止状态，等待服务器发送的连接释放报文。(此时TCP处于半关闭状态,浏览器->服务器这个方向的连接已经被释放了,即浏览器无法再向服务器发送请求,但是服务器还可以向浏览器发送)

​	iii) 第三次: 当服务器没有要向浏览器发送的数据时,发送释放连接报文给浏览器。

 iiii) 第四次: 浏览器收到连接释放报文后,向服务器发出确认。此时TCP连接并不会马上释放，必须经过2MSL(最长报文段寿命)时间后,浏览器才会进入关闭状态。(注意:在第二次挥手后,TCP处在半关闭状态,浏览器无法发送请求,但是可以发送报文)

c) 为什么四次挥手释放连接时,要等待2MSL？

为了确保浏览器发送的最后一个确认报文能够到达服务器。因为如果最后一个报文丢失了，那么服务器没有收到报文,让浏览器重新确认，而浏览器已经关闭，那么服务器就无法正常的关闭。使用了2MSL,让浏览器稍作等待,如果报文丢失,服务器重新发送释放连接报文，浏览器回应并重置2MSL计时器,直至成功。

d) 为什么要四次挥手?

因为当服务器收到浏览器的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，当服务器收到FIN报文时，很可能并不会立即关闭SOCKET（可能还有数据要传输），所以只能先回复一个ACK报文，告诉浏览器，"收到FIN报文了"。只有等到服务器所有的报文都发送完了，访服务器才能发送FIN报文，因此不能一起发送。故需要四次挥手。