-  React 常用 Hook



- useEffect 模拟哪些生命周期



- useEffect是否可以监听props改变
必须可以


- useRef和useState和区别和应用场景



- key的作用？能不能使用index作为key? 子组件的key发生改变时，会触发哪些生命周期?

```react
// 1. 默认情况下,diff算法使用是就地更新原则，即

// 2. 

// 3. key改变的时候 子组件会重新渲染，即生命周期都会重新执行，因为 子组件是否发生改变时通过判断props,而key也是props的一个，发生改变，则子组件重新渲染。
```



- 聊天列表使用无限滚动实现(对比虚拟列表)以及使用了IntersectionObserver API(上拉加载更多时,滚动条默认滚动有问题)



- 文件断点续传(自己好好理一遍)
  - 主要通过blob的slice方法对文件的内容进行分片，然后通过http请求将文件的分片进行上传，每一个分片都有自己的hash值和索引，后端根据hash进行判断小文件是否上传成功，而索引值是用来合并分片时排序的。
  - 前端默认会对文件的地址进行存储，下一次进来直接点击上传即可继续，不需要再选择文件。
  - 文件的hash是通过Web Worker 新开线程的方式进行计算的，因为JS和渲染进程是互斥的，在进行大量的Hash计算时，页面直接卡住，而新开线程则不会。
  - 网络请求的取消当时使用的是axios的CancelToken实现的
  - Http1.1现在对网络请求的并发是有限制的，一般在4到6条，之前考虑的不够细致，使用的是串行发送的方式，而没有采用并发。

- 文件断点续传
 - 通过blob.slice方法对文件进行分片,首先需要对整个文件进行hash计算得到hash值, 然后分片后需要对每个小文件进行hash, 无论是大文件还是小文件的hash都是用来后端判断文件是否上次成功,当全部上传成功后, 通过索引将小文件进行拼接
 - 前端需要通过IndexDB对文件信息进行存储, 后续进来根据文件信息判即可继续上传, 不需要再选择文件
 - 由于JS是单线程会阻塞DOM渲染, 因此大量的hash计算会阻塞DOM渲染, 所以采用了Web Worker计算hash

- 如何保证聊天信息的发送顺序？聊天消息的时间处理(默认前端存储发送时间进行存储,待后端发送成功之后,双方都会接收到最新的消息并进行更新)



- Webpack使用哪些loader以及plugin？



- sourceMap 是做什么用的？



- webpack可以做哪些构建方面的性能优化？



- webpack做一些组件的按需加载?为什么要做按需加载?



- 在react中封装原生的input标签,props包含 defaultValue、value、onChange



- ES5怎么实现一个类的功能？(通过组合继承的方式 原型链+经典继承)



- 平常通过哪些方式学习前端知识?