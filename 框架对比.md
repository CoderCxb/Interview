# Vue和React对比


### 共同点

###### 同为MVVM架构
- MVVM
  - M(Model - 模型层): JS对象,定义data以及method等
  - V(View - 视图层): DOM元素
  - VM(ViewModel - 视图模型层): 在vue中指代vue的实例,作为Model和View交互的枢纽,以input的双向绑定为例, input进行输入,VM修改Model层对应的数据,而Model层修改数据,视图层也会更新input。
理解: 视图模型层主要做的事情是通过封装逻辑简化视图层和模型层的交互  

![MVVM](./images/MVVM.png)

- MVC
  - M(Model - 模型层): 数据模型
  - V(View - 视图层): 前端页面
  - C(controller - 控制层): 路由 + 控制器 + 服务

区别: 
MVVM,视图模型层封装了视图层和模型层的交互逻辑,视图层操作以及模型层数据修改等可以直接通过VM互相影响。

控制层只是作为视图层和模型层的中间层,因此MVVM一般作为前端的架构模型,而MVC则作为后端的架构模型。

###### 虚拟DOM
虚拟DOM本质上是描述DOM结构的JS对象。

```Javascript
// 为什么使用虚拟DOM?
// 直接操作DOM的心智成本较高,因此引入虚拟DOM的概念, 通过虚拟DOM描述DOM, 当数据发生改变的时候并不直接修改DOM,而是修改虚拟DOM,然后对比新老虚拟DOM,找出差异并更新差异部分的DOM。

// 虚拟DOM其实是在保证性能的前提下,尽可能的降低开发时的心智负担和提高可维护性。

// 虚拟DOM有着更好的跨平台的能力, 可以根据不同的渲染器渲染到不同的平台
```

- Diff算法、key、以及index作为key的问题
```react
// Diff算法
// 注意：真实DOM操作修改了属性，下次diff算法的时候不会被当作改变，从而更新(可以理解为真实DOM操作后，虚拟DOM也会更新，所以会当成同一个元素继续复用)。

// key的作用？
// 虚拟DOM中，key作为一个标识，当数据发生改变时，会生成新的虚拟DOM，随后对新旧虚拟DOM就行Diff算法比较

// 标签比较的属性 (比较的最小单位是标签,子组件算一个标签-比较props等)
// a. 存在相同的key
//   1) 内容相同，直接复用旧的真实DOM
//   2) 内容不同,将不同的部分替换掉，相同部分还是复用
// b. key不同时，根据新的数据生成新的DOM节点渲染到页面

// 是否能使用index作为key吗? 为什么?
// 尽量不用,index作为key的时候就不能对前面的元素做操作了，否则会异常。
// 不如，删除第一个元素(index为0),第二个元素顶上来，这时他的index也是0,那么diff算法判断key的时候就通过了，然后比较其中的内容，如果里面的内容也没改变，那么就复用了，但是这样是异常的，因此这些内容是属于被删除的第一个元素的。
```


###### 同样是编译 + 运行时的框架


### 不同点

###### 响应式
vue通过Object.definedProperty或Proxy以及依赖收集的机制, 实现了响应式, 而React并不允许直接修改state, 而是需要使用React暴露的APi来修改

###### 